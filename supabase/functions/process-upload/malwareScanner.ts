/**
 * Malware Scanner for Edge Functions
 * Lightweight malware detection without requiring system processes
 *
 * Strategy:
 * 1. Magic byte validation (block executables, scripts)
 * 2. Suspicious file pattern detection
 * 3. File size anomaly detection
 * 4. Content signature scanning for known malware patterns
 */

export interface ScanResult {
  safe: boolean
  threat?: string
  severity?: 'low' | 'medium' | 'high' | 'critical'
  details?: string
}

/**
 * Blocked file signatures (magic bytes)
 * Source: https://en.wikipedia.org/wiki/List_of_file_signatures
 */
const BLOCKED_SIGNATURES: Array<{ signature: Uint8Array; type: string; severity: 'high' | 'critical' }> = [
  // Executables
  { signature: new Uint8Array([0x4d, 0x5a]), type: 'PE executable (EXE/DLL)', severity: 'critical' }, // MZ
  { signature: new Uint8Array([0x7f, 0x45, 0x4c, 0x46]), type: 'ELF executable', severity: 'critical' }, // ELF
  { signature: new Uint8Array([0xca, 0xfe, 0xba, 0xbe]), type: 'Mach-O executable', severity: 'critical' }, // Mach-O
  { signature: new Uint8Array([0xfe, 0xed, 0xfa, 0xce]), type: 'Mach-O 32-bit', severity: 'critical' },
  { signature: new Uint8Array([0xfe, 0xed, 0xfa, 0xcf]), type: 'Mach-O 64-bit', severity: 'critical' },

  // Scripts and Code
  { signature: new Uint8Array([0x23, 0x21]), type: 'Shell script (#!)', severity: 'high' }, // #!

  // Archives with potential issues
  { signature: new Uint8Array([0x52, 0x61, 0x72, 0x21]), type: 'RAR archive', severity: 'high' }, // Rar!
  { signature: new Uint8Array([0x37, 0x7a, 0xbc, 0xaf]), type: '7z archive', severity: 'high' }, // 7z
]

/**
 * Suspicious file extensions
 */
const BLOCKED_EXTENSIONS = new Set([
  // Executables
  'exe', 'dll', 'com', 'bat', 'cmd', 'scr', 'pif', 'app', 'deb', 'rpm',

  // Scripts
  'sh', 'bash', 'zsh', 'fish', 'ps1', 'vbs', 'vbe', 'js', 'jse', 'wsf', 'wsh',

  // System files
  'sys', 'drv', 'ocx',

  // Java/Android
  'jar', 'apk',

  // Macro-enabled documents (potential malware vectors)
  'docm', 'xlsm', 'pptm',
])

/**
 * Allowed MIME types for creative assets
 */
const ALLOWED_MIME_TYPES = new Set([
  'image/jpeg',
  'image/png',
  'image/gif',
  'video/mp4',
  'video/webm',
  'text/html',
  'application/zip',
  'text/css',
  'application/javascript', // For HTML5 bundles only
])

/**
 * Scan file for malware signatures
 */
export async function scanFile(
  fileBuffer: ArrayBuffer,
  filename: string,
  mimeType: string
): Promise<ScanResult> {
  // Step 1: Check MIME type allowlist
  if (!ALLOWED_MIME_TYPES.has(mimeType)) {
    return {
      safe: false,
      threat: 'Blocked MIME type',
      severity: 'high',
      details: `MIME type ${mimeType} not allowed for creative uploads`,
    }
  }

  // Step 2: Check file extension
  const extension = filename.split('.').pop()?.toLowerCase() || ''
  if (BLOCKED_EXTENSIONS.has(extension)) {
    return {
      safe: false,
      threat: 'Blocked file extension',
      severity: 'critical',
      details: `File extension .${extension} is not allowed`,
    }
  }

  // Step 3: Check magic bytes against blocked signatures
  const bytes = new Uint8Array(fileBuffer.slice(0, 512)) // Read first 512 bytes

  for (const { signature, type, severity } of BLOCKED_SIGNATURES) {
    if (matchesSignature(bytes, signature)) {
      return {
        safe: false,
        threat: type,
        severity,
        details: `Detected ${type} file signature`,
      }
    }
  }

  // Step 4: Validate file size (prevent zip bombs)
  const maxSize = 500 * 1024 * 1024 // 500MB
  if (fileBuffer.byteLength > maxSize) {
    return {
      safe: false,
      threat: 'File too large',
      severity: 'medium',
      details: `File size ${fileBuffer.byteLength} exceeds maximum ${maxSize}`,
    }
  }

  // Step 5: Check for suspicious patterns in first 4KB
  const suspiciousPatterns = [
    { pattern: /<script[\s>]/i, name: 'Embedded script tag' },
    { pattern: /eval\(/i, name: 'JavaScript eval()' },
    { pattern: /document\.write/i, name: 'document.write()' },
    { pattern: /on(load|error|click)=/i, name: 'Inline event handler' },
  ]

  const textContent = new TextDecoder('utf-8', { fatal: false }).decode(bytes.slice(0, 4096))

  for (const { pattern, name } of suspiciousPatterns) {
    if (pattern.test(textContent)) {
      // Allow for HTML files (HTML5 bundles)
      if (mimeType === 'text/html' && filename.toLowerCase().endsWith('.html')) {
        continue // HTML files are expected to have these patterns
      }

      return {
        safe: false,
        threat: 'Suspicious content pattern',
        severity: 'high',
        details: `Detected ${name} in non-HTML file`,
      }
    }
  }

  // File passed all checks
  return { safe: true }
}

/**
 * Scan zip archive for malware and suspicious content
 */
export async function scanZipArchive(
  zipBuffer: ArrayBuffer,
  filename: string
): Promise<ScanResult> {
  // Basic zip validation
  const bytes = new Uint8Array(zipBuffer)

  // Check for zip signature (PK)
  if (bytes[0] !== 0x50 || bytes[1] !== 0x4b) {
    return {
      safe: false,
      threat: 'Invalid zip file',
      severity: 'medium',
      details: 'File does not have valid ZIP signature',
    }
  }

  // Check for password protection (encrypted zip)
  // Encrypted zips have encryption flag (bit 0) set in general purpose bit flag
  const view = new DataView(zipBuffer)
  let offset = 0
  let hasEncryptedFiles = false

  // Parse zip central directory to check for encryption
  // Look for local file header signature (0x04034b50)
  while (offset < bytes.length - 4) {
    const signature = view.getUint32(offset, true)

    if (signature === 0x04034b50) { // Local file header
      const flags = view.getUint16(offset + 6, true)
      if (flags & 0x01) { // Encryption bit is set
        hasEncryptedFiles = true
        break
      }
      // Skip to next header (this is simplified, real implementation needs full parsing)
      const compressedSize = view.getUint32(offset + 18, true)
      const filenameLength = view.getUint16(offset + 26, true)
      const extraLength = view.getUint16(offset + 28, true)
      offset += 30 + filenameLength + extraLength + compressedSize
    } else {
      offset++
    }
  }

  if (hasEncryptedFiles) {
    return {
      safe: false,
      threat: 'Password-protected archive',
      severity: 'high',
      details: 'Encrypted/password-protected ZIP files are not supported',
    }
  }

  // Check for excessive compression ratio (zip bomb detection)
  const compressionRatio = zipBuffer.byteLength
  if (compressionRatio > 50 * 1024 * 1024 && compressionRatio < 1024 * 1024) {
    // Suspicious: Very small file that claims to decompress to huge size
    return {
      safe: false,
      threat: 'Potential zip bomb',
      severity: 'critical',
      details: 'Suspicious compression ratio detected',
    }
  }

  return { safe: true }
}

/**
 * Check if byte array starts with given signature
 */
function matchesSignature(bytes: Uint8Array, signature: Uint8Array): boolean {
  if (bytes.length < signature.length) return false

  for (let i = 0; i < signature.length; i++) {
    if (bytes[i] !== signature[i]) return false
  }

  return true
}

/**
 * Log security event for monitoring
 */
export function logSecurityEvent(
  event: 'scan_blocked' | 'scan_passed' | 'scan_error',
  details: {
    filename: string
    threat?: string
    severity?: string
    uploadSessionId?: string
  }
): void {
  // In production, this would send to a security monitoring service
  console.log('[SECURITY]', event, details)

  // Future: Send to logging service (Sentry, Datadog, etc.)
  // await fetch('https://logging-service.com/security', {
  //   method: 'POST',
  //   body: JSON.stringify({ event, ...details, timestamp: new Date().toISOString() })
  // })
}
